<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/vuepress_project/assets/css/0.styles.7e771c68.css" as="style"><link rel="preload" href="/vuepress_project/assets/js/app.d8feb981.js" as="script"><link rel="preload" href="/vuepress_project/assets/js/3.c6c41995.js" as="script"><link rel="preload" href="/vuepress_project/assets/js/1.0ce7d5d7.js" as="script"><link rel="preload" href="/vuepress_project/assets/js/10.54fe54f3.js" as="script"><link rel="prefetch" href="/vuepress_project/assets/js/11.3177cd73.js"><link rel="prefetch" href="/vuepress_project/assets/js/12.9cfc37fa.js"><link rel="prefetch" href="/vuepress_project/assets/js/13.9f2cbc04.js"><link rel="prefetch" href="/vuepress_project/assets/js/14.448cff29.js"><link rel="prefetch" href="/vuepress_project/assets/js/15.e8f33ce7.js"><link rel="prefetch" href="/vuepress_project/assets/js/16.36b9fe0a.js"><link rel="prefetch" href="/vuepress_project/assets/js/17.9d4c46bc.js"><link rel="prefetch" href="/vuepress_project/assets/js/18.fb8cca74.js"><link rel="prefetch" href="/vuepress_project/assets/js/4.16d76ed6.js"><link rel="prefetch" href="/vuepress_project/assets/js/5.5d84c24d.js"><link rel="prefetch" href="/vuepress_project/assets/js/6.11ee5d6d.js"><link rel="prefetch" href="/vuepress_project/assets/js/7.135f6719.js"><link rel="prefetch" href="/vuepress_project/assets/js/8.263b4b0b.js"><link rel="prefetch" href="/vuepress_project/assets/js/9.e4c81674.js">
    <link rel="stylesheet" href="/vuepress_project/assets/css/0.styles.7e771c68.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-130b300a><div data-v-130b300a><div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-130b300a data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2></h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2></p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-130b300a><header class="navbar" data-v-130b300a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress_project/" class="home-link router-link-active"></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress_project/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><a href="/vuepress_project/recommend/" class="nav-link"><i class="undefined"></i>
  推荐
</a></div><div class="nav-item"><a href="/vuepress_project/interview/" class="nav-link router-link-active"><i class="undefined"></i>
  面试合辑
</a></div><div class="nav-item"><a href="/vuepress_project/commonProblem/" class="nav-link"><i class="undefined"></i>
  常见问题
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-130b300a></div> <aside class="sidebar" data-v-130b300a><div class="personal-info-wrapper" data-v-39576ba9 data-v-130b300a><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>7</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/vuepress_project/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><a href="/vuepress_project/recommend/" class="nav-link"><i class="undefined"></i>
  推荐
</a></div><div class="nav-item"><a href="/vuepress_project/interview/" class="nav-link router-link-active"><i class="undefined"></i>
  面试合辑
</a></div><div class="nav-item"><a href="/vuepress_project/commonProblem/" class="nav-link"><i class="undefined"></i>
  常见问题
</a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>html</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>javaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress_project/interview/javaScript/" aria-current="page" class="active sidebar-link">JavaScript</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2></h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-130b300a><main class="page"><section><div class="page-title"><h1 class="title">JavaScript</h1> <div data-v-f875f3fc><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="javascript"><a href="#javascript" class="header-anchor">#</a> JavaScript</h1> <h2 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h2> <p><strong>1. JavaScript有哪些数据类型，他们的区别？</strong></p> <p>JavaScript有8种数据类型，分别是 <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Object</code>、<code>Symbol</code>、<code>BigInt</code></p> <p>其中<code>Symbol</code> 和 <code>BigInt</code> 是ES6中新增的数据类型：</p> <ul><li><code>Symbol</code> 代表创建后独一无二不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题</li> <li><code>BigInt</code> 是一种数字类型的数据，它可以表示任意精度格式的整数，使用<code>BigInt</code> 可以安全的存储和操作大整数，即使这个数已经超过了<code>Number</code> 能够表示的安全整数范围</li></ul> <p>这些数据可以分为原始数据类型和引用数据类型：</p> <ul><li>栈：原始数据类型（<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>）</li> <li>堆：引用数据类型（<code>对象</code>、<code>数组</code>、<code>函数</code>）</li></ul> <p>两种类型的区别在于<strong>存储位置不同</strong>：</p> <ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li> <li>引用数据类型存储在堆（heap）中的对象，占据空间大，大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会先检索其在栈中的地址，取得地址后从堆中获取实体。</li></ul> <p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p> <ul><li>在数据结构中，栈中数据的存取方式为先进后出</li> <li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定</li></ul> <p>在操作系统中，内存被分为栈区和堆区</p> <ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量值等。其操作方式类似于数据结构中的栈</li> <li>堆区内存一般由开发者分配释放，若开发者不释放，程序结束可能由垃圾回收机制回收</li></ul> <p><strong>2. 数据类型的检测方式有哪些？</strong></p> <p><strong>（1）typeof</strong></p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//number</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">)</span>            <span class="token comment">//boolean</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">'str'</span><span class="token punctuation">)</span>           <span class="token comment">//string</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>              <span class="token comment">//object</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment">//function</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>              <span class="token comment">//object</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span>       <span class="token comment">//undefined</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">//object</span>
</code></pre></div><p>其中数组、数组、null都会被判断为object,其他都判断正确</p> <p><strong>（2）instanceof</strong></p> <p><code>instanceof</code>可以正确判断数据的类型，其内部运行计制是判断在其原型链中是否能找到该类型的原型</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span>                <span class="token comment">//false</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span>            <span class="token comment">//false</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'str'</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span>            <span class="token comment">//false</span>

 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span>                <span class="token comment">//true</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span>   <span class="token comment">//true</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span>               <span class="token comment">//true</span>
</code></pre></div><p>可以看到，<code>instanceof</code> 只能正确判断引用数据类型，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的<code>prototype</code>属性</p> <p><strong>（3）constructor</strong></p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number<span class="token punctuation">)</span>                 <span class="token comment">//true</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Boolean<span class="token punctuation">)</span>             <span class="token comment">//true</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'str'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> String<span class="token punctuation">)</span>             <span class="token comment">//true</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span>                 <span class="token comment">//true</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span>    <span class="token comment">//true</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> object<span class="token punctuation">)</span>                <span class="token comment">//true</span>
</code></pre></div><p><code>constructor</code> 有两个作用，一个判断数据的类型，二是对象实例通过<code>constructor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code> 就不能用来判断数据类型了：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code> <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

 <span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Fn<span class="token punctuation">)</span>       <span class="token comment">//false</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span>    <span class="token comment">//true</span>
</code></pre></div><p><strong>（4）Object.prototype.toString.call()</strong></p> <p><code>Object.prototype.toString.call()</code> 使用Object对象的原型方法 toString来判断数据类型：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code> <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">;</span>

 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'str'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>obj.toString()结果和Object.prototype.toString.call(obj)的结果不一样，为什么？</p> <p>因为toString是object的原型方法，而Array、Function 等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法
（function类型返回内容为函数体的字符串，array类型返回元素组成的字符串...），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString（）不能得到其对象类型，只能将obj转为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法</p> <p><strong>3. 判断数组的方式有哪些？</strong></p> <ul><li>通过Object.prototype.toString.call() 做判断</li></ul> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token string">'Array'</span>
</code></pre></div><ul><li>通过原型链做判断</li></ul> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
</code></pre></div><ul><li>通过es6的Array.isArray()做判断</li></ul> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre></div><ul><li>通过instanceof判断</li></ul> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
</code></pre></div><ul><li>通过Array.prototype.isPrototypeOf</li></ul> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre></div><p><strong>4. null和undefined区别</strong></p> <p>首先undefined和null都是基本数据类型，这两个基本数据类型分别都只有一个值，就是undefined和null</p> <p>undefined 代表的含义是<strong>未定义</strong>，null代表的含义的是<strong>空对象</strong>，一般变量声明了但还没有定义的时候会返回undefined，null主要用于赋值给一些可能会返回对象的变量，做为初始化。</p> <p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用undefined来作为一个变量，但这样的做法是非常危险的，他会影响对undefined值的判断。我们可以通过一些方法获得安全的undefined值，比如说 void 0。</p> <p>当对这两种类型使用typeof进行判断时，null类型化会返回<code>object</code>,这是一个历史遗留问题。当使用双等号对两种类型的值进行比较时会返回true，使用三个等号时会返回false。</p> <p><strong>5. typeof null的结果是什么，为什么？</strong></p> <p>typeof null 的结果时Object。</p> <p>在JavaScript第一个版本中，所有值都存储在32位的单元中，每个单元包含一个小的类型标签（1-3 bits）以及当前要存储值的真是数据。类型标签存储在每个单元标签的低位中，共有5种数据类型</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>   <span class="token number">000</span>： object  <span class="token operator">-</span> 当前存储的数据指向一个对象
   <span class="token number">1</span>：int        <span class="token operator">-</span>当前存储的数据是一个<span class="token number">31</span>位的有符号整数
   <span class="token number">010</span>：double   <span class="token operator">-</span>当前存储的数据指向一个双精度的浮点数
   <span class="token number">100</span>：string   <span class="token operator">-</span>当前存储的数据指向一个字符串
   <span class="token number">110</span>：boolean  <span class="token operator">-</span>当前存储的数据是布尔值
</code></pre></div><p>如果最低位是1，则类型标签标志位的长度只有一位；如果最低位是0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外的两个bit 长度。</p> <p>有两种特殊数据类型：</p> <ul><li>undefined的值是(-2)30(一个超出整数范围的数字)</li> <li>null 的值是机器码的null 指针(null 指针的值全是0)</li></ul> <p>那也就是说null的类型标签也是000，和object的类型标签一样，所以会被判定为Object</p> <p><strong>6. instanceof 操作符的实现原理及实现</strong></p> <p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code> <span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span>right</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token comment">// 获取对象的原型</span>
     <span class="token keyword">let</span> proto<span class="token operator">=</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span>
     <span class="token comment">// 获取构造函数的prototype 对象</span>
     <span class="token keyword">let</span> prototype<span class="token operator">=</span>right<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
     <span class="token comment">//判断构造函数的prototype 对象是否在对象的原型链上</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>proto<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
         <span class="token keyword">if</span><span class="token punctuation">(</span>proto<span class="token operator">===</span>prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
         <span class="token comment">// 如果没有找到，就继续从其原型链上找，Object.getPrototypeOf方法用来获取指定对象的原型</span>
         proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre></div><p><strong>7. 为什么0.1 + 0.2 !== 0.3 ,如果让其相等</strong></p> <p>在开发过程中遇到类似这样的问题</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>   <span class="token keyword">let</span> n1 <span class="token operator">=</span> <span class="token number">0.1</span> <span class="token punctuation">,</span> n2 <span class="token operator">=</span> <span class="token number">0.2</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n1<span class="token operator">+</span>n2<span class="token punctuation">)</span> <span class="token comment">// 0.30000000000000004</span>
</code></pre></div><p>这里得到的不是想要的结果，想要等于0.3，就要把它进行转化：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token punctuation">(</span>n1 <span class="token operator">+</span> n2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 注意，toFixed为四舍五入</span>
</code></pre></div><p>toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p> <p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p> <p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p> <p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.300000000000000041</code>。</p> <p>下面看一下双精度数是如何保存的：</p> <p><img src="/vuepress_project/assets/img/_1.0ef8f46f.png" alt="floatingPoint"></p> <ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li> <li>第二部分（绿色）：用来存储指数（exponent），占用11位</li> <li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul> <p>对于0.1，它的二进制为：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="token number">10011.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p>转为科学计数法（科学计数法的结果就是浮点数）：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token number">1.1001100110011001100110011001100110011001100110011001</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">^</span><span class="token operator">-</span><span class="token number">4</span>
</code></pre></div><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token number">1001100110011001100110011001100110011001100110011001</span>
</code></pre></div><p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p> <p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p> <ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是-1022~1013。</li> <li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。</li> <li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。</li></ul> <p>对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.</p> <p>所以，0.1表示为：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token number">0</span> <span class="token number">1111111011</span> <span class="token number">1001100110011001100110011001100110011001100110011001</span>
</code></pre></div><p>说了这么多，是时候该最开始的问题了，如何实现<code>0.1+0.2=0.3</code>呢？</p> <p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是<code>2-52</code>，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为<code>0.1+0.2 ===0.3</code></p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">numberepsilon</span><span class="token punctuation">(</span><span class="token parameter">arg1<span class="token punctuation">,</span>arg2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   
 <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>arg1 <span class="token operator">-</span> arg2<span class="token punctuation">)</span> <span class="token operator">&lt;</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">;</span>        
<span class="token punctuation">}</span>        
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">numberepsilon</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p><strong>8. 如何获取安全的 undefined 值？</strong></p> <p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p> <p><strong>9. typeof NaN 的结果是什么？</strong></p> <p>NaN指 '不是一个数字（not a number）',NaN是一个'警戒值'（sentinel value,有特殊用途的常规值），用于指出数字类型中错误情况，即 '执行数学计算没成功，这是失败后返回的结果'。</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token number">NaN</span> <span class="token punctuation">;</span>    <span class="token comment">// 'number' </span>
</code></pre></div><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive,即 x===x不成立）的值。而NaN !== NaN 为true</p> <p><strong>10. isNaN 和Number.isNaN函数的区别？</strong></p> <ul><li>函数isNaN 接受参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的值都会返回true,因此非数字值传入也会返回true,会影响NaN的判断1</li> <li>函数Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为NaN,不会进行数据类型的转换，这种方法对于NaN的判断更为准确。</li></ul> <p><strong>11. ==操作符的强制类型转换规则？</strong></p> <p>对于<code>==</code>来说，如果对比双方的类型不一样，就会进行 <strong>类型转换</strong>。假如对比<code>x</code> 和 <code>y</code>是否相同，就会进行如下判断流程：</p> <ol><li><p>首先会判断两者类型是否相同，如果相同，则会比较两者的大小</p></li> <li><p>类型不同的话，就会进行类型转化</p></li> <li><p>会先判断是否在对比<code>null</code>和<code>undefined</code>,是的话就返回true</p></li> <li><p>判断两者类型是否为<code>string</code>和<code>number</code>,是的话就将字符串转换为<code>number</code></p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token number">1</span> <span class="token operator">==</span> <span class="token string">'1'</span>
     ↓
<span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span>
</code></pre></div></li> <li><p>判断其中一方是否是<code>object</code>且另一方为<code>string</code>、<code>number</code>或者<code>symbol</code>,是的话就把<code>object</code>转为原始类型在进行判断</p></li></ol> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code> <span class="token string">'1'</span> <span class="token operator">==</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'js'</span><span class="token punctuation">}</span>
                 ↓
 <span class="token string">'1'</span> <span class="token operator">==</span> <span class="token string">'[object object]'</span>
</code></pre></div><p>其流程图如下：
<img src="/docs/.vuepress/assets/_2.png" alt="object"></p> <p><strong>12. 其他值转到字符串的转换规则？</strong></p> <ul><li>Null 和 Undefined 类型，null转为<code>null</code>，  <code>undefined</code>转换为<code>undefined</code>,</li> <li>Boolean 类型，true转换为<code>true</code>,false转换为 <code>false</code></li> <li>Number 类型的值直接转换，不过那些极大和极小的数字会使用指数形式</li> <li>Symbol 类型的值直接转换，但是只允许显示强制类型转换，使用隐式强制类型转换会产生错误</li> <li>对普通类型来说，除非自定义toString()方法，否则会调用toString()(Object.prototype.toString())来返回内部属性[[Class]]的值，如 <code>[object,object]</code>。如果对象有自己的toString方法，字符串转化时就会调用该方法并使用其返回值。</li></ul> <p><strong>13. 其他值到数字值的转换规则</strong></p> <ul><li>undefined 类型的值转换为NaN</li> <li>Null 类型的值转换为0</li> <li>Boolean 类型的值，true转换为1，false转换为0</li> <li>String 类型的值转换如同使用Number() 函数进行转换，如果包含非数字值转换为NaN,空字符串为0</li> <li>Symbol 类型的值不能转换为数字，会报错</li> <li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转化为数字</li></ul> <p>为了将值转换为相应的基本类型值，抽象操作ToPrimitive会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制转换，如果没有就使用toString()的返回值（如果存在）来进行强制类型转换</p> <p>如果valueOf()和toString()均不返回基本类型值，会产生TypeError值</p> <p><strong>14. 其他值到布尔类型值的转换规则？</strong></p> <p>以下这些是假值：<code>undefined</code>、<code>null</code>、<code>false</code>、<code>+0 -0</code>、<code>NaN</code>、<code>''</code>
假值的布尔强制类型转换结果为<code>false</code>,从逻辑上说，假值列表以外的都应该是真值</p> <p><strong>15. || 和 &amp;&amp; 操作符的返回值？</strong></p> <p><code>||</code> 和 <code>&amp;&amp;</code> 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断</p> <ul><li>对于 <code>||</code> 来说，如果判断条件为true就返回第一个操作的数的值，如果为false就返回第二个操作数的值</li> <li><code>&amp;&amp;</code> 则相反，如果判断条件为true就返回第二个操作的数的值，如果为false就返回第一个操作数的值</li></ul> <p><code>||</code> 和 <code>&amp;&amp;</code> 返回他们其中一个操作数的值，而非判断条件的结果</p> <p><strong>16. Object.is() 与 比较操作符 &quot;===&quot; 、&quot;==&quot;的区别？</strong></p> <ul><li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转换后再进行比较</li> <li>使用双等号（===）进行相等判断时，如果两边的类型不一致，不会进行强制类型转换，直接返回false</li> <li>使用Object.is进行相当判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，就比如<code>-0</code>和<code>+0</code>不再相等，两个NaN是相等的</li></ul> <p><strong>17. 什么是JavaScript中的包装类型</strong></p> <p>在JavaScript中，基本类型时没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或者方法时，JavaScript会在后台隐式的将基本类型值转为对象，如：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token string">'abc'</span>
a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'ABC'</span>
</code></pre></div><p>在访问 <code>abc.length</code>时，JavaScript将<code>abc</code>在后台转<code>String('abc')</code>，然后再访问其&quot;length&quot;属性</p> <p>JavaScript也可以使用Object函数显式的将基本类型转为包装类型：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'abc'</span>
<span class="token function">Object</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// String{'abc'}</span>
</code></pre></div><p>也可以使用valueOf方法将包装类型倒转成基本类型</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>   <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'abc'</span>
   <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
   <span class="token keyword">var</span> c <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'abc'</span>
</code></pre></div><p>看看如下代码会打印出什么:</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>   <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Oops'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不运行</span>
   <span class="token punctuation">}</span>
</code></pre></div><p>答案是什么都不会打印，因为虽然包裹的基本类型是false，但是false被包裹成包装类型后就成了对象，所以其非值为false，所以循环体中的内容不会运行</p> <p><strong>18. JavaScript 中如何进行隐式类型转换？</strong></p> <p>首先要介绍<code>ToPrimitive</code>方法，这是JavaScript中每个值隐含的自带的方法，用来将值（无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
* @obj 需转换的对象
* @type 期望的结果类型
*/</span>
<span class="token function">ToPrimitive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
</code></pre></div><p><code>type</code>的值为<code>number</code>或<code>string</code></p> <p>(1)当type为number时规则如下：</p> <ul><li>调用obj的valueOf方法，如果为原始值，则返回，否则下一步；</li> <li>调用obj的toString方法，后续同上；</li> <li>抛出TypeError 异常。</li></ul> <p>（2）当type为string时规则如下：</p> <ul><li>调用obj的toString方法，如果为原始值，则返回，否则下一步；</li> <li>调用obj的valueOf方法，后续同上；</li> <li>抛出TypeError 异常。</li></ul> <p>可以看出两者的主要区别在于调用toString和valueOf的先后顺序。默认情况下：</p> <ul><li>如果对象为 Date 对象，则type默认为string；</li> <li>其他情况下，type默认为number。</li></ul> <p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>   <span class="token keyword">var</span> <span class="token function-variable function">objToNumber</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token function">Number</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token function">objToNumber</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span>
   <span class="token function">objToNumber</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">NaN</span>
</code></pre></div><p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、</code>/以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p> <p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p> <ol><li><code>+</code>操作符</li></ol> <p><code>+</code>操作符的两边有至少一个string类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'23'</span> <span class="token comment">// '123'</span>
    <span class="token number">1</span> <span class="token operator">+</span> <span class="token boolean">false</span> <span class="token comment">// 1 </span>
    <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Uncaught TypeError: Cannot convert a Symbol value to a number</span>
    <span class="token string">'1'</span> <span class="token operator">+</span> <span class="token boolean">false</span> <span class="token comment">// '1false'</span>
    <span class="token boolean">false</span> <span class="token operator">+</span> <span class="token boolean">true</span> <span class="token comment">// 1</span>
</code></pre></div><ol start="2"><li><code>-、*、\</code>操作符</li></ol> <p><code>NaN</code>也是一个数字</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token number">1</span> <span class="token operator">*</span> <span class="token string">'23'</span> <span class="token comment">// 23</span>
    <span class="token number">1</span> <span class="token operator">*</span> <span class="token boolean">false</span> <span class="token comment">// 0</span>
    <span class="token number">1</span> <span class="token operator">/</span> <span class="token string">'aa'</span> <span class="token comment">// NaN</span>
</code></pre></div><ol start="3"><li>对于<code>==</code>操作符</li></ol> <p>操作符两边的值都尽量转成number：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token number">3</span> <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token comment">// false, 3 转为number为3，true转为number为1</span>
    <span class="token string">'0'</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token comment">//true, '0'转为number为0，false转为number为0</span>
    <span class="token string">'0'</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token comment">// '0'转为number为0</span>
</code></pre></div><ol start="4"><li>对于<code>&lt;</code>和<code>&gt;</code>比较符</li></ol> <p>如果两边都是字符串，则比较字母表顺序：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token string">'ca'</span> <span class="token operator">&lt;</span> <span class="token string">'bd'</span> <span class="token comment">// false</span>
    <span class="token string">'a'</span> <span class="token operator">&lt;</span> <span class="token string">'b'</span> <span class="token comment">// true</span>
</code></pre></div><p>其他情况下，转换为数字再比较：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token string">'12'</span> <span class="token operator">&lt;</span> <span class="token number">13</span> <span class="token comment">// true</span>
    <span class="token boolean">false</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// true</span>
</code></pre></div><p>以上说的是基本类型的隐式转换，而对象会被ToPrimitive转换为基本类型再进行转换：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    a <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token comment">// false</span>
</code></pre></div><p>其对比过程如下：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// {}, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span>
    a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Object]&quot;，现在是一个字符串了</span>
    <span class="token function">Number</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span>
    <span class="token number">NaN</span> <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token comment">//false，得出比较结果</span>
</code></pre></div><p>又比如：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'Jack'</span><span class="token punctuation">}</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">}</span>
    a <span class="token operator">+</span> b <span class="token comment">// &quot;[object Object][object Object]&quot;</span>
</code></pre></div><p>运算过程如下：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// {}，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span>
    a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Object]&quot;</span>
    b<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 同理</span>
    b<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Object]&quot;</span>
    a <span class="token operator">+</span> b <span class="token comment">// &quot;[object Object][object Object]&quot;</span>
</code></pre></div><p><strong>19. <code>+</code>操作符什么时候用于字符串的拼接？</strong></p> <p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。
简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p> <p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p> <p><strong>20. 为什么会有BigInt的提案？</strong></p> <p>JavaScript中<code>Number.MAX_SAFE_INTEGER</code>表示最⼤安全数字，计算结果是<code>9007199254740991</code>，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了<code>BigInt</code>来解决此问题。</p> <p><strong>21. <code>object.assign</code>和扩展运算符是深拷贝还是浅拷贝，两者区别</strong></p> <p><code>扩展运算符</code>:</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token keyword">let</span> outObj <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">inObj</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token literal-property property">b</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>outObj<span class="token punctuation">}</span>
    newObj<span class="token punctuation">.</span>inObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outObj<span class="token punctuation">)</span> <span class="token comment">// {inObj: {a:2, b:2}}</span>
</code></pre></div><p><code>Object.assign()</code>:</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token keyword">let</span> outObj <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">inObj</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> newObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>outObj<span class="token punctuation">)</span>
    newObj<span class="token punctuation">.</span>inObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outObj<span class="token punctuation">)</span>  <span class="token comment">// {inObj:{a:2, b:2}}</span>
</code></pre></div><p>可以看到两者都是浅拷贝</p> <ul><li><code>Object.assign()</code>方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它修改了一个对象，因此会触发ES6 <code>setter</code></li> <li><code>扩展运算符（...）</code>使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或者对象中。它不复制继承的属性或者类的属性，但他会复制ES6的<code>symbol</code>属性</li></ul> <h2 id="es6"><a href="#es6" class="header-anchor">#</a> ES6</h2> <p><strong>1.var与 let &amp; const 的区别</strong></p> <p><strong>(1)块级作用域</strong>：块级作用域由<code>{ }</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的2个问题：</p> <ul><li>内层变量可能覆盖外层变量</li> <li>用来计数的循环变量泄露为全局变量</li></ul> <p><strong>(2)变量提升</strong>:var 存在变量提升，let 和 const 不存在变量提升，即在变量只能在声明之后使用，否则会报错</p> <p><strong>(3)给全局添加属性</strong>：浏览器的全局属性是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let 和 const 不会</p> <p><strong>(4)重复声明</strong>：var 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的变量。let 和 const 不允许重复声明变量</p> <p><strong>(5)暂时性死区</strong>：在使用let 、const 声明变量前，该变量都是不可用的。在语法上，这叫 <strong>暂时性死区</strong>，使用var 声明的变量不存在暂时性死区</p> <p><strong>(6)初始值设置</strong>：在变量声明时，var 可以不用设置初始值，而const 声明变量必须设置初始值</p> <p><strong>(7)指针指向</strong>：let 和 const 都是ES6新增的用于创建变量的语法。let 创建的变量可以更改指针指向（可以重新赋值）。但const 声明的变量不允许改变指针的指向</p> <table><thead><tr><th><div style="width:400px;">区别</div></th> <th><div style="width:70px;">var</div></th> <th><div style="width:70px;">let</div></th> <th><div style="width:70px;">const</div></th></tr></thead> <tbody><tr><td>是否有块级作用域</td> <td>×</td> <td>√</td> <td>√</td></tr> <tr><td>是否存在变量提升</td> <td>√</td> <td>×</td> <td>×</td></tr> <tr><td>是否添加全局属性</td> <td>√</td> <td>×</td> <td>×</td></tr> <tr><td>能否重复变量声明</td> <td>√</td> <td>×</td> <td>×</td></tr> <tr><td>是否存在暂时性死区</td> <td>×</td> <td>√</td> <td>√</td></tr> <tr><td>是否必须设置初始值</td> <td>×</td> <td>×</td> <td>√</td></tr> <tr><td>能否改变指针指向</td> <td>√</td> <td>√</td> <td>×</td></tr></tbody></table> <p><strong>2. const 对象的属性可以修改吗？</strong>
const 保证的并不是变量的值不能改动，而是变量指向的那个内存地址不可改动。对于基本数据类型（数字、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量</p> <p>但对于<code>引用类型</code>的数据（主要是数组个对象）来说，变量指向数据的内存地址，保存的只是一个指针，const 只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就不能完全控制了</p> <p><strong>3.如果new一个箭头函数会怎样？</strong></p> <p>箭头函数是ES6中提出来的，它没有prototype,也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p> <p>new操作符的实现步骤如下：</p> <ul><li><p>创建一个对象</p></li> <li><p>将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</p></li> <li><p>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</p></li> <li><p>返回新的对象</p> <p>所以，上面的2、3步，箭头函数是无法执行的</p></li></ul> <p><strong>4. 箭头函数和普通函数的区别</strong></p> <p>(1) 箭头函数比普通函数更加简洁</p> <ul><li>如果没有参数，直接写一个空括号即可</li> <li>如果只有一个参数，可以省去参数的括号</li> <li>如果有多个参数，用逗号分割</li> <li>如果函数体的返回值只有一句话，可以省略大括号</li> <li>如果函数体不需要返回值，且只有一句话，可以给这个语句前加一个void关键字。最常见的就是调用一个函数：</li></ul> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token function">doseNotReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>(2) 箭头函数没有自己的this</p> <p>箭头函数不会创建自己的this,所以它没有自己this,它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在定义时已经确定了，之后不会改变</p> <p>(3) 箭头函数继承来的this指向永远不会改变</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token keyword">var</span> id <span class="token operator">=</span> <span class="token string">'GLOBAL'</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>
        <span class="token literal-property property">id</span><span class="token operator">:</span><span class="token string">'OBJ'</span><span class="token punctuation">,</span>
        <span class="token function-variable function">a</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">b</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    obj<span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 'OBJ'</span>
    obj<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 'GLOBAL'</span>
    <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>
    <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Uncaught TypeError: obj.b is not a constructor</span>
</code></pre></div><p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this,即使这个函数是作为对象obj的方法调用，this依旧指向window对象。需要注意，定义对象的大括号<code>{}</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中</p> <p>(4)<code>call()</code>、<code>apply()</code>、<code>bind()</code>等方法不能改变箭头函数中this的指向</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token keyword">var</span> id <span class="token operator">=</span> <span class="token string">'GLOBAL'</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token function-variable function">fun1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fun1</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'Obj'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token comment">// 'GLOBAL'</span>
    <span class="token function">fun1</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'Obj'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>     <span class="token comment">// 'GLOBAL'</span>
    <span class="token function">fun1</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'Obj'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 'GLOBAL'</span>
</code></pre></div><p>(5) 箭头函数不能作为构造函数使用</p> <p>构造函数new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。但是由于箭头函数没有自己的this，且this指向的是外层的执行环境，且不能改变指向，所以不能当做构造函数使用</p> <p>(6) 箭头函数没有自己的<code>arguments</code></p> <p>箭头函数没有自己的<code>arguments</code>对象，在箭头函数中访问的<code>arguments</code> 实际上获得的是它外层函数的<code>arguments</code>值</p> <p>(7) 箭头函数没有prototype</p> <p>(8) 箭头函数不能作为generator函数，不能使用yeild关键字</p> <p>(9) 箭头函数的this指向哪里？</p> <p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有自己的this,它所谓的this是捕获其上下文的this值，作为自己的this值，并且由于没有自己的this，所以是不会被new 调用的，这个所谓的this 也不会被改变</p> <p>可以用babel理解一下箭头函数:</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token comment">// ES6</span>
    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token function">getArrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> obj<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>转化后</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token comment">// ES5 由babel 转译</span>
    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">getArrow</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">getArrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">var</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_this <span class="token operator">===</span> obj<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>6. 扩展运算符的作用及使用场景</strong></p> <p>(1) 对象扩展运算符</p> <p>对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象中</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code> <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">let</span> bz<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">...</span>bar<span class="token punctuation">}</span>  <span class="token comment">// {a:1 ,b:2}</span>
</code></pre></div><p>上述方法实际上等价于：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code> <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">let</span> bz<span class="token operator">=</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>bar<span class="token punctuation">)</span>  <span class="token comment">// {a:1 ,b:2}</span>
</code></pre></div><ul><li><p><code>Object.assign()</code>方法用于对象的合并，将源对象<code>(source)</code>的所有和枚举属性，复制到目标对象<code>(target)</code>。</p></li> <li><p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。（如果目标对象和源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性）</p></li></ul> <div class="language- extra-class"><pre><code>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉

```JavaScript
    let bar = {a: 1, b: 2};
    let bz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}
```
利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数，reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回

需要注意：扩展运算符对对象实例的拷贝属于浅拷贝
</code></pre></div></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vuepress_project/interview/html/" class="prev">
            html
          </a></span> <span class="next"><a href="/vuepress_project/interview/vue/">
            vue
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/vuepress_project/interview/javaScript/#数据类型" class="sidebar-link reco-side-数据类型" data-v-cb1513f6>数据类型</a></li><li class="level-2" data-v-cb1513f6><a href="/vuepress_project/interview/javaScript/#es6" class="sidebar-link reco-side-es6" data-v-cb1513f6>ES6</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/vuepress_project/assets/js/app.d8feb981.js" defer></script><script src="/vuepress_project/assets/js/3.c6c41995.js" defer></script><script src="/vuepress_project/assets/js/1.0ce7d5d7.js" defer></script><script src="/vuepress_project/assets/js/10.54fe54f3.js" defer></script>
  </body>
</html>
